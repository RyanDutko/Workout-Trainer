Make these minimal edits in ai_service_v2.py. Do not refactor unrelated code.

1) In _commit_plan_update, force the circuit/rounds write path and return early

Find the function:

def _commit_plan_update(self, proposal_id: str) -> Dict[str, Any]:


Right after we load the proposal and open the DB connection (i.e., after:

proposal = self.pending_proposals.get(proposal_id)
day = proposal['day']
action = proposal['action']
# we may have: block = proposal['block']  (leave it)
conn = self.db.get_connection()
cursor = conn.cursor()


), insert the following block before any existing insert logic:

import json

# ---------- Unified add_block circuit/rounds path ----------
if action == "add_block":
    # Pull from either key; some versions store only 'block'
    nb = proposal.get("normalized_block") or {}
    blk = proposal.get("block") or {}
    if not isinstance(nb, dict):
        try: nb = json.loads(nb)
        except Exception: nb = {}
    if not isinstance(blk, dict):
        try: blk = json.loads(blk)
        except Exception: blk = {}

    # Prefer normalized
   u = nb or blk
    block_type = (u.get("block_type") or "single").lower()
    if block_type == "complex":
        block_type = "circuit"
    label      = (u.get("label") or u.get("exercise") or "Block").strip()
    order_idx  = u.get("order_index") or 99
    rounds     = int(u.get("rounds") or u.get("meta_json", {}).get("rounds") or 1)
    members    = u.get("members") or []
    meta       = (u.get("meta_json") or u.get("meta") or {}).copy()
    meta.setdefault("rounds", rounds)

    # If this is a complex block, write it as circuit/rounds and RETURN EARLY
    if block_type in ("circuit", "rounds"):
        # Compute order if not specified
        if order_idx == 99:
            cursor.execute(
                "SELECT COALESCE(MAX(exercise_order), 0) + 1 FROM weekly_plan WHERE LOWER(day_of_week) = ?",
                (day.lower(),)
            )
            order_idx = int(cursor.fetchone()[0] or 1)

        cursor.execute(
            """
            INSERT INTO weekly_plan
                (day_of_week, exercise_name, target_sets, target_reps, target_weight,
                 block_type, meta_json, members_json, exercise_order, created_by, newly_added, date_added)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
            (
                day.lower(),
                label,                     # store block label in exercise_name
                rounds,                    # target_sets helps template fallback
                "",                        # reps blank at block-level
                "",                        # weight blank at block-level
                block_type,                # "circuit" or "rounds"
                json.dumps(meta),
                json.dumps(members),
                int(order_idx),
                "ai_v2",
                True,
                datetime.now().strftime("%Y-%m-%d"),
            ),
        )
        conn.commit()
        block_id = cursor.lastrowid

        # Clean up the proposal NOW and return early so the single-fallback never runs
        try:
            del self.pending_proposals[proposal_id]
        except Exception:
            pass

        print(f"COMMIT_ADD branch=circuit label={label!r} rounds={rounds} members={len(members)}")

        updated_plan = self._get_weekly_plan(day)
        print(f"POST_WRITE_VERIFY day={day} blocks={len(updated_plan)}")
        return {
            "status": "ok",
            "block_id": block_id,
            "wrote": True,
            "updated_plan": updated_plan,
        }
# ---------- end unified circuit/rounds path ----------


Leave the rest of the function (the simple/single fallback) untouched beneath this. Because we return inside the circuit/rounds branch, the fallback wonâ€™t execute for complex blocks.