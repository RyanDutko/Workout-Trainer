Please make the following minimal, surgical changes. Do not refactor unrelated code.

1) ai_service_v2.py — normalize “complex” to “circuit” and preserve rounds

In the function that builds the proposed block (the code path that handles the propose_plan_update tool and constructs normalized_block), make these changes:

Normalize synonyms:

block_type = (block.get("block_type") or "single").lower()
if block_type == "complex":
    block_type = "circuit"


Make sure rounds is captured and defaults to 1 only if not provided:

rounds = int(block.get("rounds") or 1)


When creating normalized_block, keep meta_json from either meta_json or meta and include rounds:

normalized_block = {
    "block_type": block_type,
    "label": label,
    "order_index": order_index,
    "rounds": rounds,
    "meta_json": (block.get("meta_json") or block.get("meta") or {}),
    "members": members,
    "sets": []
}


If the type is circuit/rounds, pre-expand planned sets for each round so they’re visible to the UI/template:

if block_type in ("circuit", "rounds"):
    for r in range(rounds):
        for mi, m in enumerate(members):
            normalized_block["sets"].append({
                **m,
                "block_type": block_type,
                "member_idx": mi,
                "set_idx": r,        # 0-based
                "round_index": r+1,  # 1-based for UI
                "status": "planned"
            })


Keep your existing remove behavior (it’s working now), but ensure the summary line is correct (already appears fixed in the last change).

2) app.py — add /logging_template route

Add this route (near other Flask routes). It returns a template the UI can render for the selected date. It reads the weekly_plan rows, parses block_type, meta_json, members_json, and emits a simple, future-proof structure: simple blocks → flat members; circuit/rounds → rounds with per-member planned fields.

from datetime import datetime
import json

@app.route('/logging_template', methods=['GET'])
def logging_template():
    try:
        date = request.args.get('date') or datetime.now().strftime('%Y-%m-%d')
        day_name = datetime.strptime(date, '%Y-%m-%d').strftime('%A').lower()

        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute('''
            SELECT
                id,
                day_of_week,
                exercise_name,
                COALESCE(target_sets, 0),
                COALESCE(target_reps, ''),
                COALESCE(target_weight, ''),
                COALESCE(block_type, 'single') AS block_type,
                COALESCE(meta_json, '{}')      AS meta_json,
                COALESCE(members_json, '[]')   AS members_json,
                exercise_order
            FROM weekly_plan
            WHERE LOWER(day_of_week) = ?
            ORDER BY exercise_order
        ''', (day_name,))
        rows = cursor.fetchall()
        conn.close()

        # Build a dynamic template the UI can render
        blocks = []
        for (row_id, _dow, name, t_sets, t_reps, t_weight, btype, meta_json, members_json, _order) in rows:
            try:
                meta = json.loads(meta_json) if meta_json else {}
            except Exception:
                meta = {}
            try:
                members = json.loads(members_json) if members_json else []
            except Exception:
                members = []

            btype_l = (btype or "single").lower()

            # Simple block
            if btype_l == "single":
                blocks.append({
                    "block_id": f"BLK-{row_id}",
                    "type": "simple",
                    "title": name,
                    "members": [{
                        "name": name,
                        "input_id": f"BLK-{row_id}.S1",
                        "planned_reps": t_reps,
                        "planned_weight": t_weight
                    }]
                })
                continue

            # Circuit / Rounds block
            rounds = None
            # Prefer explicit meta.rounds; fall back to target_sets
            if isinstance(meta, dict) and "rounds" in meta:
                try:
                    rounds = int(meta["rounds"])
                except Exception:
                    rounds = None
            if rounds is None:
                try:
                    rounds = int(t_sets or 1)
                except Exception:
                    rounds = 1
            if rounds < 1:
                rounds = 1

            # Members should contain at least name/reps/weight
            # Expected shape: [{"exercise": "...", "reps": 10, "weight": "20 lbs", ...}, ...]
            # Map to UI-friendly fields
            round_list = []
            for r in range(1, rounds+1):
                r_members = []
                for mi, m in enumerate(members):
                    ex_name = m.get("exercise") or m.get("name") or name
                    planned_reps = m.get("reps", t_reps)
                    planned_weight = m.get("weight", t_weight)
                    r_members.append({
                        "name": ex_name,
                        "input_id": f"BLK-{row_id}.R{r}.{mi}",
                        "planned_reps": planned_reps,
                        "planned_weight": planned_weight
                    })
                round_list.append({
                    "round_index": r,
                    "members": r_members
                })

            blocks.append({
                "block_id": f"BLK-{row_id}",
                "type": "rounds",
                "title": name,
                "rounds": round_list
            })

        template = {"date": date, "blocks": blocks}
        return jsonify({"success": True, "template": template}), 200

    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


Notes/assumptions (don’t change other code):

weekly_plan already has block_type, meta_json, members_json columns (there’s code that ALTER TABLE adds them if missing).

For circuits/rounds we prefer meta_json.rounds; if absent we fall back to target_sets.

The response shape is { success, template: { date, blocks: [...] } }, which the UI can consume.