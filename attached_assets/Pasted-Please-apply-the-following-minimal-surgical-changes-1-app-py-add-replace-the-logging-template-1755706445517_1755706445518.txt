Please apply the following minimal, surgical changes.

1) app.py — add/replace the /logging_template route

Create (or replace) a Flask route that builds a dynamic logging template from weekly_plan. It must work for both simple rows and circuit/rounds rows, and return a payload that’s compatible with either data.template.blocks or data.blocks.

# at top if not present
from datetime import datetime
import json

@app.route('/logging_template', methods=['GET'])
def logging_template():
    try:
        date = request.args.get('date') or datetime.now().strftime('%Y-%m-%d')
        day_name = datetime.strptime(date, '%Y-%m-%d').strftime('%A').lower()

        conn = get_db_connection()
        c = conn.cursor()
        c.execute("""
            SELECT
                id,
                exercise_name,
                COALESCE(target_sets, 0)    AS t_sets,
                COALESCE(target_reps, '')   AS t_reps,
                COALESCE(target_weight, '') AS t_weight,
                COALESCE(block_type, 'single') AS btype,
                COALESCE(meta_json, '{}')      AS meta_json,
                COALESCE(members_json, '[]')   AS members_json,
                COALESCE(exercise_order, 999)  AS ord
            FROM weekly_plan
            WHERE LOWER(day_of_week) = ?
            ORDER BY ord
        """, (day_name,))
        rows = c.fetchall()
        conn.close()

        blocks = []
        for (row_id, name, t_sets, t_reps, t_weight, btype, meta_js, members_js, _ord) in rows:
            # parse json safely
            try: meta = json.loads(meta_js) if meta_js else {}
            except Exception: meta = {}
            try: members = json.loads(members_js) if members_js else []
            except Exception: members = []

            btype_l = (btype or 'single').lower()

            if btype_l in ('circuit', 'rounds'):
                # rounds: prefer meta.rounds, else fallback to target_sets
                try:
                    rounds = int(meta.get('rounds', t_sets or 1))
                except Exception:
                    rounds = 1
                rounds = max(1, rounds)

                round_list = []
                for r in range(1, rounds + 1):
                    r_members = []
                    for i, m in enumerate(members):
                        ex = m.get('exercise') or m.get('name') or name
                        planned_reps = m.get('reps', t_reps)
                        planned_weight = m.get('weight', t_weight)
                        r_members.append({
                            "name": ex,
                            "input_id": f"BLK-{row_id}.R{r}.{i}",
                            "planned_reps": planned_reps,
                            "planned_weight": planned_weight
                        })
                    round_list.append({"round_index": r, "members": r_members})

                blocks.append({
                    "block_id": f"BLK-{row_id}",
                    "type": "rounds",
                    "title": name,
                    "rounds": round_list
                })
            else:
                # simple block
                blocks.append({
                    "block_id": f"BLK-{row_id}",
                    "type": "simple",
                    "title": name,
                    "members": [{
                        "name": name,
                        "input_id": f"BLK-{row_id}.S1",
                        "planned_reps": t_reps,
                        "planned_weight": t_weight
                    }]
                })

        payload = {"date": date, "blocks": blocks}
        print(f"TEMPLATE_OUT date={date} blocks={len(blocks)}")  # debug

        # Return a shape that works for both old/new frontends
        # (data.template.blocks or data.blocks)
        return jsonify({
            "success": True,
            "template": payload,
            "date": date,
            "blocks": blocks
        }), 200
    except Exception as e:
        print(f"/logging_template error: {e}")
        return jsonify({"success": False, "error": str(e)}), 500

2) templates/log_workout.html (or the JS it loads) — make the fetch tolerant

Find the JS that fetches the template (it may currently call /get_plan/... or /logging_template?...). Update it to accept either data.template or top-level data:

<script>
async function loadTemplate(dateStr) {
  try {
    const resp = await fetch(`/logging_template?date=${encodeURIComponent(dateStr)}`);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();
    // accept either shape
    const tpl = data.template || { date: data.date, blocks: data.blocks };
    if (!tpl || !Array.isArray(tpl.blocks)) throw new Error("Bad template payload");
    renderLoggingUI(tpl); // your existing renderer that builds inputs
    document.getElementById('templateError')?.classList.add('hidden');
  } catch (err) {
    console.error("Template load failed:", err);
    const el = document.getElementById('templateError');
    if (el) {
      el.textContent = "Template loading failed";
      el.classList.remove('hidden');
    }
  }
}
</script>


Make sure there’s an element like:

<div id="templateError" class="hidden text-red-600 text-sm"></div>

3) Restart the server

Then open /log_workout and watch the server console for TEMPLATE_OUT ....

No other changes.